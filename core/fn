#!/bin/bash

service::get_dirs() {
  string::split : $PLUGIN_SERVICE_SERVICES
}

service::get_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[service::get_config_path] name is required"
    exit 1
  fi

  echo $PLUGIN_SERVICE_SERVICES/$name
}

service::get_mod_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::get_mod_path] name is required"
    exit 1
  fi

  local service_path=$(service::get_path $name)
  echo $service_path/mod
}

service::get_config_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[service::get_config_path] name is required"
    exit 1
  fi

  echo $PLUGIN_SERVICE_SERVICES/$name/config
}

service::get_repo_url() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::get_repo_url] name is required"
    exit 1
  fi

  echo ${PLUGIN_SERVICE_PREFIX}${name}
}

service::list() {
  local avaliable_service_dirs=$(service::get_dirs)
  log "List all available services"
  log ""

  for service_dir in $avaliable_service_dirs; do
    # local namespace=$(echo $service_dir | awk -F '/' '{print $(NF-0)}')
    local namespace=$(string::split_last_element '/' $service_dir)
    if [ ! -d $service_dir ]; then
      log "  namespace: $namespace ($service_dir)"
      log "    (no avaliable services)"
      log ""
      continue
    fi

    local service_names=$(ls $service_dir)
    # local service_count=$(echo $service_names | wc -w)
    local service_count=0
    for service_name in $service_names; do
      local service_path=$service_dir/$service_name

      # Check is a real service
      if [ -f $service_path/docker-compose.yml ]; then
        service_count=$((service_count + 1))
      fi
    done

    log "  namespace: $namespace (total: $service_count) ($service_dir)"
    local index=0
    for service_name in $service_names; do
      local service_path=$service_dir/$service_name

      # Check is a real service
      if [ -f $service_path/docker-compose.yml ]; then
        index=$(number::step index)
        log "    $(color::success "$index $service_name")"
      fi
    done

    if [ $service_count -eq 0 ]; then
      log "    (no avaliable services)"
    fi

    log ""
  done
}

service::list_sub_services() {
  local name=$1
  local service_path=$(service::get_path $name)
  if [ "$service_path" = "" ]; then
    log::error "[$(timestamp)][service] service($name) not found"
    exit 1
  fi

  if [ ! -d "$service_path" ]; then
    log::error "[$(timestamp)][service] service($name) not found"
    exit 1
  fi
  
  # @TODO
  service::load_config $name

  cd $service_path
  docker-compose -f docker-compose.yml ps --services
}

service::run() {
  local name=$1
  local commands=${@:2}
  local service_path=$(service::get_path $name)

  log::debug "[$(timestamp)][service] PLUGIN_SERVICE_SERVICES: $PLUGIN_SERVICE_SERVICES"
  log::debug "[$(timestamp)][service] service name: $name"
  log::debug "[$(timestamp)][service] service path: $service_path"
  log::debug "[$(timestamp)][service] service command: $commands"

  if [ "$service_path" = "" ]; then
    log::error "[$(timestamp)][service] service($name) not found"
    exit 1
  fi

  if [ ! -d "$service_path" ]; then
    log::error "[$(timestamp)][service] service($name) not found"
    exit 1
  fi

  # @TODO
  service::load_config $name

  # #@TODO
  # service::run_check $name
  # if [ "$?" != "0" ]; then
  #   log::error "[service::run] service run check error"
  #   exit 1
  # fi

  cd $service_path
  log::debug "[$(timestamp)][service] docker-compose -f docker-compose.yml $commands"
  docker-compose -f docker-compose.yml $commands
}

service::run_check() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[service::run_check] name is required"
    exit 1
  fi

  local service_check_path="$(service::get_path $name)/check"
  if [ ! -f "$service_check_path" ]; then
    exit 0
  fi

  # custom check
  # $service_check_path
  # @TODO use . cannot load env
  . $service_check_path
}

service::run_check_ok() {
  export SERVICE_RUN_CHECK_OK=true
}

service::get_config() {
  local service_name=$1

  local service_path=$(service::get_path $service_name)
  if [ "$service_path" = "" ]; then
    log::error "[$(timestamp)][service] service($service_name) not found"
    exit 1
  fi

  local service_config=$service_path/docker-compose.yml
  if [ ! -f $service_config ]; then
    log::error "[$(timestamp)][service] service($service_name) config(docker-compose.yml) not found"
  fi

  echo $service_config
}

service::get_data_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[service::get_data_path] name is required"
    exit 1
  fi

  local path="$PLUGIN_SERVICE_DATA/$name"
  if [ ! -d "$path" ]; then
    if [ ! -w "PLUGIN_SERVICE_DATA" ]; then
      sudo mkdir -p $path
      sudo chown $USER $path
    else
      mkdir -p $path
    fi 
  fi

  echo $path
}

service::get_logs_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[service::get_logs_path] name is required"
    exit 1
  fi

  local path="$PLUGIN_SERVICE_LOGS/$name"
  if [ ! -d "$path" ]; then
    if [ ! -w "PLUGIN_SERVICE_DATA" ]; then
      sudo mkdir -p $path
      sudo chown $USER $path
    else
      mkdir -p $path
    fi 
  fi

  echo $path
}

service::get_configs_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[service::get_logs_path] name is required"
    exit 1
  fi

  local path="$PLUGIN_SERVICE_CONFIGS/$name"
  if [ ! -d "$path" ]; then
    if [ ! -w "PLUGIN_SERVICE_DATA" ]; then
      sudo mkdir -p $path
      sudo chown $USER $path
    else
      mkdir -p $path
    fi 
  fi

  echo $path
}

service::load_mod() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::load_mod] name is required"
    exit 1
  fi

  local service_mod_path=$(service::get_mod_path $name)
  if [ ! -f $service_mod_path ]; then
    log::error "[$(timestamp)][service::load_mod] name is required"
    exit 1
  fi

  config::load_file $service_mod_path
}

service::load_config() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::load_config] name is required"
    exit 1
  fi

  # @TODO
  export SERVICE_DIR=$(service::get_path $name)
  if [ ! -d "$SERVICE_DIR" ]; then
    log::error "[$(timestamp)][service::load_config] service is not invalid"
    exit 1
  fi

  export SERVICE_DATA=$(service::get_data_path $name)
  export SERVICE_LOGS=$(service::get_logs_path $name)
  export SERVICE_CONFIGS=$(service::get_configs_path $name)
  export SERVICE_CONFIG=$SERVICE_CONFIGS/config

  if [ -z "$SERVICE_DATA" ]; then
    log::error "[service::run] SERVICE_DATA is empty"
    exit 1
  fi

  if [ -z "$SERVICE_LOGS" ]; then
    log::error "[service::run] SERVICE_LOGS is empty"
    exit 1
  fi

  if [ "$SERVICE_CONFIG" = "/config" ]; then
    log::error "[service::run] SERVICE_CONFIG is not valid"
    exit 1
  fi

  local service_config_path=$(service::get_config_path $name)
  if [ -f "$service_config_path" ]; then
    config::load_file $service_config_path
  fi

  # log::info "SERVICE_DATA: $SERVICE_DATA"
  # log::info "SERVICE_LOGS: $SERVICE_LOGS"
  # log::info "SERVICE_CONFIG: $SERVICE_CONFIG"

  # @TODO load global
  if [ -f "$SERVICE_CONFIG" ]; then
    config::load_file $SERVICE_CONFIG
  fi

  #@TODO
  service::run_check $name
  if [ "$?" != "0" ]; then
    log::error "[service::run] service run check error"
    exit 1
  fi
}

service::clone() {
  local name=$1
  local version=$2
  local alias_=$3

  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::clone] name is required"
    exit 1
  fi

  if [ -z "$version" ]; then
    version=master
  fi

  if [ -z "$alias_" ]; then
    alias_=$name
  fi

  local service_path=$(service::get_path $alias_)
  local service_repo_url=$(service::get_repo_url $name)
  if [ ! -d "$service_path" ]; then
    curl -I $service_repo_url 2>>/dev/null | head -n 1 | grep 404 >>/dev/null 2>&1
    if [ "$?" = "0" ]; then
      log::error "[$(timestamp)][service::clone] service ${name} is not available"
      exit 1
    fi

    git clone $service_repo_url -b $version $service_path >>$ZMICRO_LOG_COMMON_PATH # 2>>$ZMICRO_LOG_ERROR_PATH
    if [ "$?" != "0" ]; then
      log::error "[$(timestamp)][service::clone] error $name($version) ..."
      exit 1
    fi
  else
    cd $service_path
    git pull origin master >> $ZMICRO_LOG_UPDATE_PATH 2>>$ZMICRO_LOG_ERROR_PATH
    if [ "$?" != "0" ]; then
      echo "[$(timestamp)][service::clone] update service repo ${name} ..."
      tail -n 50 $ZMICRO_LOG_ERROR_PATH
      exit -1
    fi
  fi
}

service::install() {
  local name=$1
  local version=$2
  local alias_=$3
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::install] name is required"
    exit 1
  fi

  if [ -z "$alias_" ]; then
    alias_=$name
  fi

  # download
  service::clone $name $version $alias_

  # start service
  if [ "$SERVICE_AUTO_START" != "N" ]; then
    service::run $name up -d
  fi
}

service::remove() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::remove] name is required"
    exit 1
  fi

  local service_path=$(service::get_path $name)
  if [ ! -d "$service_path" ]; then
    log::error "[$(timestamp)][service::remove] service($name) not found"
    exit 1
  fi

  # stop service
  service::run $name down

  # remove service dir
  rm -rf $service_path
}

service::update() {
  local name=$1
  local args=${@:2}
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::update] name is required"
    exit 1
  fi

  # update repo
  service::clone $name $version

  # pull
  service::run $name pull $args
  # build
  service::build $name
  # rollup
  service::run $name down $args
  service::run $name up -d $args
}

service::version() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::version] name is required"
    exit 1
  fi

  # @TODO
  if [ ! -f "$(service::get_mod_path $name)" ]; then
    echo "-"
    return
  fi

  service::load_mod $name
  echo $VERSION
}

service::description() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::description] name is required"
    exit 1
  fi

  if [ ! -f "$(service::get_mod_path $name)" ]; then
    echo "No Description"
    return
  fi

  service::load_mod $name
  echo $DESCRIPTION
}

service::get_image_path() {
  local name=$1
   if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::image] name is required"
    exit 1
  fi

  local service_path=$(service::get_path $name)
  echo $service_path/image/Dockerfile
}

service::build() {
  local name=$1
  local args=${@:2}
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service::get_mod_path] name is required"
    exit 1
  fi

  local dockerfile=$(service::get_image_path $name)
  if [ -f "$dockerfile" ]; then
    # log::info "Build image ..."
    service::run $name build $args
  fi
}

service::apply() {
  run::js $ZMICRO_PLUGINS_PATH/service/core/js/apply.js "$@"
}

service::version_echo() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][service][version_echo] service name is required"
    exit 1
  fi

  version::service $name
}

export -f service::get_dirs
export -f service::get_path

export -f service::get_mod_path
export -f service::get_config_path
export -f service::get_repo_url
export -f service::get_image_path

export -f service::get_config

export -f service::get_data_path
export -f service::get_logs_path
export -f service::get_configs_path

export -f service::load_mod
export -f service::load_config

export -f service::run
export -f service::list
export -f service::list_sub_services

export -f service::clone
export -f service::install
export -f service::remove
export -f service::update

export -f service::build

export -f service::version
export -f service::description

export -f service::run_check
export -f service::run_check_ok

export -f service::apply

export -f service::version_echo